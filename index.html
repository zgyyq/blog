<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zgyyq.github.io","root":"/blog/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="最光阴写字的地方">
<meta property="og:url" content="https://zgyyq.github.io/blog/index.html">
<meta property="og:site_name" content="最光阴写字的地方">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="最光阴">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zgyyq.github.io/blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>最光阴写字的地方</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">最光阴写字的地方</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/08/24/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/Netty%E4%B8%AD%E7%9A%84ChannelInitializer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/08/24/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/Netty%E4%B8%AD%E7%9A%84ChannelInitializer/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-24 21:50:46" itemprop="dateCreated datePublished" datetime="2023-08-24T21:50:46+08:00">2023-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/07/22/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/Reactor%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/07/22/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/Reactor%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-22 17:15:57" itemprop="dateCreated datePublished" datetime="2023-07-22T17:15:57+08:00">2023-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-26 11:23:31" itemprop="dateModified" datetime="2023-07-26T11:23:31+08:00">2023-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/07/11/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/Netty%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0EventLoopGroup%E3%80%81EventLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/07/11/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/Netty%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0EventLoopGroup%E3%80%81EventLoop/" class="post-title-link" itemprop="url">Netty中的EventLoop和线程模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-11 11:46:37" itemprop="dateCreated datePublished" datetime="2023-07-11T11:46:37+08:00">2023-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:32:57" itemprop="dateModified" datetime="2023-08-26T17:32:57+08:00">2023-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">Netty源码美学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一篇文章中学习到，EventLoop是一个单线程、用于处理一个连接的所有 I&#x2F;O 事件和用户任务的执行器。</p>
<h1 id="继承图"><a href="#继承图" class="headerlink" title="继承图"></a>继承图</h1><p><img src="/blog/img/netty/EventLoop%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="img"></p>
<p>首先来看下提交任务的方法：</p>
<h1 id="SingleThreadEventExecutor-execute"><a href="#SingleThreadEventExecutor-execute" class="headerlink" title="SingleThreadEventExecutor#execute"></a>SingleThreadEventExecutor#execute</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">    execute0(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">execute0</span><span class="params">(<span class="meta">@Schedule</span> Runnable task)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(task, <span class="string">&quot;task&quot;</span>);</span><br><span class="line">    execute(task, wakesUpForTask(task));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task, <span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前运行的线程是不是该EventLoop绑定的线程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        <span class="comment">// 如果不是EventLoop绑定的线程，就启动线程</span></span><br><span class="line">        startThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>addTask：将runnable任务添加到任务队列中。在SingleThreadEventExecutor中维护了这么一个任务队列。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Runnable&gt; taskQueue;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>启动线程的逻辑调用链是startThread()-&gt;doStartThread()，而主要的逻辑都集中在doStartThread()方法中，我们着重分析。</p>
<h2 id="SingleThreadEventExecutor-doStartThread"><a href="#SingleThreadEventExecutor-doStartThread" class="headerlink" title="SingleThreadEventExecutor#doStartThread"></a>SingleThreadEventExecutor#doStartThread</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doStartThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 通过executor启动一个新的task，在该task里启动线程</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 将启动线程绑定到本地线程（后续轮训执行任务的就是该线程）</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用run()方法，开始轮训事件循环</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="built_in">this</span>.run();</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里可能有点懵，不是说启动线程吗？怎么又有一个执行器，又要提交任务了？这不是循环套娃了？<br>其实不然，这里的executor是之前就初始化了的ThreadPerTaskExecutor，在execute()内部会新创建一个线程，然后启动线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = ObjectUtil.checkNotNull(threadFactory, <span class="string">&quot;threadFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以doStartThread()可以直接理解为<strong>新创建了一个线程，并绑定到EventLoop中，后续使用该线程执行任务。</strong></p>
<p>而整个EventLoop最核心的其实是轮训事件循环run()方法，我们再深入探讨。</p>
<h2 id="NioEventLoop-run"><a href="#NioEventLoop-run" class="headerlink" title="NioEventLoop#run"></a>NioEventLoop#run</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">selectCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// NioEventLoop事件循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> strategy;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断当前任务队列中是否存在任务（taskQueue是否为空），如果taskQueue不为空，则调用selectNow方法（不阻塞线程）</span></span><br><span class="line">                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">                <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">                    <span class="comment">// taskQueue为空，没有待执行任务，则调用select方法（会阻塞线程）</span></span><br><span class="line">                    strategy = select(curDeadlineNanos);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            selectCnt++;</span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 此线程分配给 IO 操作所占的时间比(即运行 processSelectedKeys 耗时在整个循环中所占用的时间)</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">            <span class="type">boolean</span> ranTasks;</span><br><span class="line">            <span class="comment">// 如果时间占比100% 则不考虑时间占比，分别调用 processSelectedKeys()、runAllTasks()</span></span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    ranTasks = runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// strategy &gt; 0 证明还有IO事件</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录下 processSelectedKeys() 所执行的时间(即 IO 操作的耗时), 然后根据公式, 计算出执行 task 所占用的时间, 然后以此为参数, 调用 runAllTasks().</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;.</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                    ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 无IO时间，仅执行任务队列</span></span><br><span class="line">                ranTasks = runAllTasks(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个for(;;) 主要是干了两件事：</p>
<ol>
<li><p>检查taskQueue是否为空，决定是否阻塞当前线程（selectNow、select）。这个两个方法都是检测当前是否有IO就绪事件，如果有, 则返回就绪 IO 事件的个数; 如果没有, 则返回0。<br>selectNow() 是立即返回的, 不会阻塞当前线程，select(timeoutMillis)是会阻塞住当前线程的, timeoutMillis 是阻塞的超时时间. </p>
</li>
<li><p>执行事件（IO事件、队列任务）：</p>
</li>
</ol>
<ul>
<li>processSelectedKeys(): 根据字面意思, 这个方法肯定是查询就绪的 IO 事件, 然后处理它</li>
<li>runAllTasks()：这个方法就是运行 taskQueue 中的任务。<br>而两种事件的运行有各自的时间占比，简单来说就是我就一个线程，要执行两种不同类型的事件，那我什么时候执行IO事件、什么时候执行任务队列呢？答案是根据一定的数学公式计算出各自的执行时间占比，平衡执行效率。<br>默认是时间占比ioRatio&#x3D;50，则 IO 操作和执行 task 的所占用的线程执行时间比是 1 : 1。</li>
</ul>
<h2 id="NioEventLoop-processSelectedKeys"><a href="#NioEventLoop-processSelectedKeys" class="headerlink" title="NioEventLoop#processSelectedKeys"></a>NioEventLoop#processSelectedKeys</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeys</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="literal">null</span>) &#123;</span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 JVM 平台的不同selectedKeys会设置不同的值，但无论是 processSelectedKeysOptimized()还是processSelectedKeysPlain()这两个方法的底层都是大同小异的。<br>我们在这里仅分析processSelectedKeysOptimized()。</p>
<h2 id="NioEventLoop-processSelectedKeysOptimized"><a href="#NioEventLoop-processSelectedKeysOptimized" class="headerlink" title="NioEventLoop#processSelectedKeysOptimized"></a>NioEventLoop#processSelectedKeysOptimized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeysOptimized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">k</span> <span class="operator">=</span> selectedKeys.keys[i];</span><br><span class="line">        selectedKeys.keys[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> k.attachment();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">            <span class="comment">// null out entries in the array to allow to have it GC&#x27;ed once the Channel close</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/2363</span></span><br><span class="line">            selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            selectAgain();</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就做了两个事：迭代selectedKeys获取就绪的IO事件、处理IO事件。</p>
<p>值得关注的是，我们可以调用 selectionKey.attach(object) 给一个 selectionKey 设置一个附加的字段, 然后可以通过 Object attachedObj &#x3D; selectionKey.attachment() 获取它. 上面代代码正是通过了 k.attachment() 来获取一个附加在 selectionKey 中的对象。</p>
<p>而这个对象正是之前在AbstractNioChannel#doRegister注册的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>接下来我们分别分析Netty是如何执行IO事件和任务事件的。</p>
<h2 id="NioEventLoop-processSelectedKey"><a href="#NioEventLoop-processSelectedKey" class="headerlink" title="NioEventLoop#processSelectedKey"></a>NioEventLoop#processSelectedKey</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取unsafe操作类</span></span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.<span class="type">NioUnsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> ch.unsafe();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readyOps</span> <span class="operator">=</span> k.readyOps();</span><br><span class="line">        <span class="comment">// 处理连接事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ops</span> <span class="operator">=</span> k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理写事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span></span><br><span class="line">            unsafe.forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理读事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见其完全对应了Java NIO 的 Selector 的那一套处理流程：</p>
<ul>
<li>OP_READ, 可读事件, 即 Channel 中收到了新数据可供上层读取.</li>
<li>OP_WRITE, 可写事件, 即上层可以向 Channel 写入数据.</li>
<li>OP_CONNECT, 连接建立事件, 即 TCP 连接已经建立, Channel 处于 active 状态.</li>
</ul>
<p>处理各种事件的详细分析留给后面介绍Netty其他组件时再介绍，现在我们来宏观地看下Netty的线程模型。</p>
<h2 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h2><p>Netty 抽象出两组线程池：BossGroup 和 WorkerGroup。<br>每个线程池中都有多个 NioEventLoop 线程。BossGroup 中的线程专门负责和客户端建立连接，WorkerGroup 中的线程专门负责处理连接上的读写。</p>
<p>NioEventLoop 表示一个不断循环的执行事件处理的线程，每个 NioEventLoop 都包含一个 Selector，用于监听注册在其上的 Socket 网络连接（Channel）。</p>
<p>所以 BossNioEventLoop 中循环执行以下三个步骤：</p>
<ol>
<li>select：轮询注册在其上的 ServerSocketChannel 的 就绪 事件（select()、selectNow()方法）</li>
<li>processSelectedKeys：处理 accept 事件，与客户端建立连接，生成一个 NioSocketChannel，并将其注册到某个 WorkerNioEventLoop 上的 Selector 上</li>
<li>runAllTasks：再去以此循环处理任务队列中的其他任务</li>
</ol>
<p>每个 WorkerNioEventLoop 中循环执行以下三个步骤：</p>
<ol>
<li>select：轮询注册在其上的 NioSocketChannel 的 read&#x2F;write 事件（OP_READ&#x2F;OP_WRITE 事件）</li>
<li>processSelectedKeys：在对应的 NioSocketChannel 上处理 read&#x2F;write 事件</li>
<li>runAllTasks：再去以此循环处理任务队列中的其他任务</li>
</ol>
<p><img src="/blog/img/netty/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/07/11/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/Netty%E8%B4%A3%E4%BB%BB%E9%93%BEpipeline%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/07/11/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/Netty%E8%B4%A3%E4%BB%BB%E9%93%BEpipeline%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">Netty的责任链Pipeline</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-11 11:46:37" itemprop="dateCreated datePublished" datetime="2023-07-11T11:46:37+08:00">2023-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-16 19:40:06" itemprop="dateModified" datetime="2023-08-16T19:40:06+08:00">2023-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">Netty源码美学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面我们介绍了Netty中Channel的初始化，让我们再回顾下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractChannel</span><span class="params">(Channel parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见在构造方法中同时初始化了Pipeline。</p>
<p>一个 Channel 包含了一个 ChannelPipeline，ChannelPipeline内部是一个双向的链表结构，内部由一个个的ChannelHandlerContext节点组成，ChannelPipeline有头尾两个固定的节点HeadContext与TailContext。用户自定的ChannelHandler就是由ChannelHandlerContext包装成Pipeline的节点，参与Channel整个生命周期中所触发的入站事件与出站事件以及相应数据流的拦截处理。</p>
<h1 id="Pipeline-关系图"><a href="#Pipeline-关系图" class="headerlink" title="Pipeline 关系图"></a>Pipeline 关系图</h1><p><img src="/blog/img/netty/Pipeline%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="img"></p>
<p>最常见的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line"> .channel(NioServerSocketChannel.class)<span class="comment">// (3)</span></span><br><span class="line"> .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="comment">// (4)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DiscardServerHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="DefaultChannelPipeline-addLast"><a href="#DefaultChannelPipeline-addLast" class="headerlink" title="DefaultChannelPipeline#addLast"></a>DefaultChannelPipeline#addLast</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">addLast</span><span class="params">(ChannelHandler... handlers)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addLast(<span class="literal">null</span>, handlers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(handlers, <span class="string">&quot;handlers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addLast(executor, <span class="literal">null</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查是否重复</span></span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">        <span class="comment">// 添加进链表尾部</span></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/06/09/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/06/09/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%85%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Netty服务端启动全流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-09 15:25:57" itemprop="dateCreated datePublished" datetime="2023-06-09T15:25:57+08:00">2023-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-02 10:58:03" itemprop="dateModified" datetime="2023-08-02T10:58:03+08:00">2023-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Netty%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">Netty源码美学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务端启动demo"><a href="#服务端启动demo" class="headerlink" title="服务端启动demo"></a>服务端启动demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscardServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DiscardServer</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">// (1)</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); <span class="comment">// (2)</span></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">// (3)</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="comment">// (4)</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DiscardServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)          <span class="comment">// (5)</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>); <span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Bind and start to accept incoming connections.</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(port).sync(); <span class="comment">// (7)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span></span><br><span class="line">            <span class="comment">// shut down your server.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DiscardServer</span>(port).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进入源码分析前，我们先了解Netty的基本组件，在心里有个底，避免在海量源码中迷失。</p>
<h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><ol>
<li>Bootstrap：Bootstrap 是用于启动和配置 Netty 应用程序的工具类。它负责配置 EventLoopGroup、ChannelFactory、Handler 等组件，并提供了简化的接口用于快速构建客户端或服务器的网络应用。ServerBootstrap 类用于创建服务端实例，Bootstrap 用于创建客户端实例。</li>
<li>EventLoopGroup：可以理解为一个线程池，其中包含多个 EventLoop。每个 EventLoop 负责处理一个或多个 Channel 的 I&#x2F;O 事件，并在事件发生时触发相应的回调函数。</li>
<li>EventLoop：负责处理各种事件，例如接收新的连接、读取数据、写入数据等。它类似于一个消息循环，不断地从任务队列中取出任务并执行。Netty 使用 EventLoop 实现了高效的事件驱动模型，支持处理成千上万个并发连接。</li>
<li>Channel：Channel 是 Netty 的核心抽象，表示一个网络连接或一个可以进行 I&#x2F;O 操作的实体。它提供了异步的 I&#x2F;O 操作，可以读取、写入和关闭连接。通过 Channel，可以实现客户端和服务器之间的数据交换。</li>
<li>Handler：Handler 是 Netty 的另一个核心概念，用于处理事件和数据的读写。它负责对进入和离开的数据进行编码和解码，以及业务逻辑的处理。Netty 提供了一系列内置的处理器，可以根据具体需求进行组合和扩展。</li>
<li>Pipeline：Pipeline 是一系列的 Handler 链接在一起形成的处理链。每个 Channel 都有自己的 Pipeline，用于处理进入和离开的数据。当数据进入 Channel 时，会依次经过 Pipeline 中的 Handler 进行处理，从而实现数据的编码、解码和业务逻辑的处理。</li>
</ol>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="NioEventLoopGroup的初始化"><a href="#NioEventLoopGroup的初始化" class="headerlink" title="NioEventLoopGroup的初始化"></a>NioEventLoopGroup的初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br></pre></td></tr></table></figure>
<p>在server端会创建两个EventLoopGroup，boosGroup用于接收Tcp请求，他会将请求交给workerGroup，workerGroup会获取真正的连接，然后和连接进行通信，比如读写解码编码等操作。</p>
<p>再看看NioEventLoopGroup的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, (Executor) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跟到参数最全的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(nThreads, executor, chooserFactory, selectorProvider, selectStrategyFactory, rejectedExecutionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看构造方法中的各个参数：</p>
<ul>
<li>nThreads：这个就是线程池中的线程数，也就是 NioEventLoop 的实例数量。默认是cpu核心数 * 2</li>
<li>executor：执行器，在这里先留个印象，后续介绍NioEventLoop时再详细介绍</li>
<li>chooserFactory：当我们提交一个任务到线程池的时候，线程池需要选择（choose）其中的一个线程来执行这个任务，这个就是用来实现选择策略的。</li>
<li>selectorProvider：用于指定SelectorProvider的实例。SelectorProvider是Java NIO中用于创建Selector对象的提供者。</li>
<li>selectStrategyFactory：用于选择处理事件的策略。在介绍 NioEventLoop 的时候会说。</li>
<li>rejectedExecutionHandler：拒绝策略。了解Java线程池应该都不会陌生，用于应对没有可用线程执行任务的情况。</li>
</ul>
<p>再来看看真正干实事的构造方法：</p>
<h3 id="MultithreadEventExecutorGroup-MultithreadEventExecutorGroup"><a href="#MultithreadEventExecutorGroup-MultithreadEventExecutorGroup" class="headerlink" title="MultithreadEventExecutorGroup#MultithreadEventExecutorGroup"></a>MultithreadEventExecutorGroup#MultithreadEventExecutorGroup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查线程参数，如果传入的参数小于等于0，则直接抛出异常</span></span><br><span class="line">    checkPositive(nThreads, <span class="string">&quot;nThreads&quot;</span>);</span><br><span class="line">    <span class="comment">// executor 如果是 null，会创建默认的执行器</span></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建指定线程数的执行器数组</span></span><br><span class="line">    children = <span class="keyword">new</span> <span class="title class_">EventExecutor</span>[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化线程执行器</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果启动失败，会关闭线程并且停止EventExecutor</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待这些线程成功 shutdown</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    <span class="type">EventExecutor</span> <span class="variable">e</span> <span class="operator">=</span> children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// 设置中断状态，让调用方处理中断</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将线程池数组传进去，实例化选择器</span></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个 Listener 用来监听该线程池的 termination 事件</span></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> <span class="title class_">FutureListener</span>&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 readonlyChildren，它是只读集合，暂时没有使用到</span></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看看默认的执行器</p>
<h3 id="ThreadPerTaskExecutor"><a href="#ThreadPerTaskExecutor" class="headerlink" title="ThreadPerTaskExecutor"></a>ThreadPerTaskExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = ObjectUtil.checkNotNull(threadFactory, <span class="string">&quot;threadFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadPerTaskExecutor 的逻辑就是每来一个任务，新建一个线程。</p>
<p>再来看看newChild()方法</p>
<h3 id="NioEventLoopGroup-newChild"><a href="#NioEventLoopGroup-newChild" class="headerlink" title="NioEventLoopGroup#newChild"></a>NioEventLoopGroup#newChild</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> EventLoop <span class="title function_">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SelectorProvider</span> <span class="variable">selectorProvider</span> <span class="operator">=</span> (SelectorProvider) args[<span class="number">0</span>];</span><br><span class="line">    <span class="type">SelectStrategyFactory</span> <span class="variable">selectStrategyFactory</span> <span class="operator">=</span> (SelectStrategyFactory) args[<span class="number">1</span>];</span><br><span class="line">    <span class="type">RejectedExecutionHandler</span> <span class="variable">rejectedExecutionHandler</span> <span class="operator">=</span> (RejectedExecutionHandler) args[<span class="number">2</span>];</span><br><span class="line">    <span class="type">EventLoopTaskQueueFactory</span> <span class="variable">taskQueueFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">EventLoopTaskQueueFactory</span> <span class="variable">tailTaskQueueFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">argsLength</span> <span class="operator">=</span> args.length;</span><br><span class="line">    <span class="keyword">if</span> (argsLength &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        taskQueueFactory = (EventLoopTaskQueueFactory) args[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argsLength &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        tailTaskQueueFactory = (EventLoopTaskQueueFactory) args[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NioEventLoop</span>(<span class="built_in">this</span>, executor, selectorProvider,</span><br><span class="line">            selectStrategyFactory.newSelectStrategy(),</span><br><span class="line">            rejectedExecutionHandler, taskQueueFactory, tailTaskQueueFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说，就是提供各种参数创建NioEventLoop实例。后续会详细分析。</p>
<h3 id="DefaultEventExecutorChooserFactory-newChooser"><a href="#DefaultEventExecutorChooserFactory-newChooser" class="headerlink" title="DefaultEventExecutorChooserFactory#newChooser"></a>DefaultEventExecutorChooserFactory#newChooser</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EventExecutorChooser <span class="title function_">newChooser</span><span class="params">(EventExecutor[] executors)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PowerOfTwoEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GenericEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里设置的策略也很简单：</p>
<ol>
<li>如果线程池的线程数量是 2^n，采用位运算的方式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果不是，用取模的方式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> executors[(<span class="type">int</span>) Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="ServerBootstrap的创建"><a href="#ServerBootstrap的创建" class="headerlink" title="ServerBootstrap的创建"></a>ServerBootstrap的创建</h2><p>Bootstrap 是用于启动和配置 Netty 应用程序的工具类。ServerBootstrap包含着ChannelHandler信息以及EventLoopGroup等信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InternalLogger</span> <span class="variable">logger</span> <span class="operator">=</span> InternalLoggerFactory.getInstance(ServerBootstrap.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The order in which child ChannelOptions are applied is important they may depend on each other for validation</span></span><br><span class="line">    <span class="comment">// purposes.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;ChannelOption&lt;?&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;AttributeKey&lt;?&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ServerBootstrapConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrapConfig</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup childGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServerBootstrap-group"><a href="#ServerBootstrap-group" class="headerlink" title="ServerBootstrap#group"></a>ServerBootstrap#group</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServerBootstrap <span class="title function_">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> &#123;</span><br><span class="line">    <span class="comment">// 将bossGroup放入父类AbstractBootstrap</span></span><br><span class="line">    <span class="built_in">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.childGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置childGroup</span></span><br><span class="line">    <span class="built_in">this</span>.childGroup = ObjectUtil.checkNotNull(childGroup, <span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServerBootstrap-channel"><a href="#ServerBootstrap-channel" class="headerlink" title="ServerBootstrap#channel"></a>ServerBootstrap#channel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;C&gt;(</span><br><span class="line">            ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory((ChannelFactory&lt;C&gt;) channelFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(channelFactory, <span class="string">&quot;channelFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;channelFactory set already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.channelFactory = channelFactory;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其主要作用是添加了一个Channel的class对象，引导类将通过这个Class对象反射创建ChannelFactory，通过channelFactory 再反射创建Channel.<br>Channel的创建在bind方法中，调用了ChannelFactory的newChannel方法。</p>
<p>剩下的childHandler、childOption、option 都是在ServerBootstrap引导类中设置相关参数，源码没什么可考究的，这里就不展开了。<br>主要来看看bind()方法</p>
<h3 id="AbstractBootstrap-bind"><a href="#AbstractBootstrap-bind" class="headerlink" title="AbstractBootstrap#bind"></a>AbstractBootstrap#bind</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(InetAddress inetHost, <span class="type">int</span> inetPort)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(inetHost, inetPort));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">//基础参数验证</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化和注册，Channel的创建和初始化pipeline就是在这做的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">        <span class="comment">// 进行端口绑定</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractBootstrap-initAndRegister"><a href="#AbstractBootstrap-initAndRegister" class="headerlink" title="AbstractBootstrap#initAndRegister"></a>AbstractBootstrap#initAndRegister</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 真正创建Channel的方法，在此处通过工厂进行了实例化</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册channel（详见下文）</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上文中介绍了ServerBootstrap#channel方法中注入了NioServerSocketChannel.class，在initAndRegister()会将其实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newChannel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(<span class="string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实例化该对象时会调用构造方法，NioServerSocketChannel在构造方法中初始化了一些东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioServerSocketChannel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_SELECTOR_PROVIDER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioServerSocketChannel</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(provider, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioServerSocketChannel</span><span class="params">(SelectorProvider provider, InternetProtocolFamily family)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Java Nio的channel</span></span><br><span class="line">    <span class="built_in">this</span>(newChannel(provider, family));</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> &#123;</span><br><span class="line">    <span class="comment">// 将Java Nio的channel传递给父类组建Netty的Channel</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="literal">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="comment">// 创建NioServerSocketChannelConfig 对象</span></span><br><span class="line">    config = <span class="keyword">new</span> <span class="title class_">NioServerSocketChannelConfig</span>(<span class="built_in">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在父类（AbstractChannel）构造方法中会生成唯一的ChannelId、创建Unsafe对象、初始化Pipeline</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractChannel</span><span class="params">(Channel parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>再来看看init()方法</p>
<h3 id="ServerBootstrap-init"><a href="#ServerBootstrap-init" class="headerlink" title="ServerBootstrap#init"></a>ServerBootstrap#init</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">   <span class="comment">// 设置channel选项</span></span><br><span class="line">   setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">   <span class="comment">// 设置channel的属性</span></span><br><span class="line">   setAttributes(channel, newAttributesArray());</span><br><span class="line">   <span class="comment">// 获取ChannelPipeline</span></span><br><span class="line">   <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// childGroup 是上文demo中的workerGroup，具体可看ServerBootstrap#group</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">EventLoopGroup</span> <span class="variable">currentChildGroup</span> <span class="operator">=</span> childGroup;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">ChannelHandler</span> <span class="variable">currentChildHandler</span> <span class="operator">=</span> childHandler;</span><br><span class="line">   <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions = newOptionsArray(childOptions);</span><br><span class="line">   <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = newAttributesArray(childAttrs);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将ChannelInitializer实例作为handler 添加到pipeline中，处理消息。现在先留个印象，后续介绍handler、eventLoop时会详细介绍</span></span><br><span class="line">   p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">           <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> config.handler();</span><br><span class="line">           <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">               pipeline.addLast(handler);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ch.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                   pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">                           ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在initAndRegister()方法中，上文介绍了channel的初始化，现在让我们来看看channel的注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config().group().register(channel);</span><br></pre></td></tr></table></figure>

<p>上面的 config().group() 方法会返回前面实例化的 NioEventLoopGroup 的实例，然后调用其 register(channel) 方法</p>
<h3 id="MultithreadEventLoopGroup-register："><a href="#MultithreadEventLoopGroup-register：" class="headerlink" title="MultithreadEventLoopGroup#register："></a>MultithreadEventLoopGroup#register：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next() 方法会选择线程池中的一个线程（chooserFactory 选择策略），也就是选择一个 NioEventLoop 实例。</p>
<p>NioEventLoop#register方法的主要实现是在其父类中：SingleThreadEventLoop。</p>
<h3 id="SingleThreadEventLoop-register"><a href="#SingleThreadEventLoop-register" class="headerlink" title="SingleThreadEventLoop#register"></a>SingleThreadEventLoop#register</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="built_in">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Netty中Unsafe类专门用来封装底层实现，后续也会出文章专门介绍，在这里可以理解为封装了网络通讯的基本操作。</p>
<p>首先来看下register()方法吧：</p>
<h3 id="AbstractChannel-AbstractUnsafe-register"><a href="#AbstractChannel-AbstractUnsafe-register" class="headerlink" title="AbstractChannel#AbstractUnsafe#register"></a>AbstractChannel#AbstractUnsafe#register</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 将 eventLoop 实例设置给这个 channel，后续该 channel 中的所有异步操作，都要提交给这个 eventLoop 来执行</span></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发起 register 动作的线程就是 eventLoop 实例中的线程，那么直接调用 register0(promise)</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，提交任务给 eventLoop，eventLoop 中的线程会负责调用 register0(promise)</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">    <span class="comment">// 将Channel 注册到 Selector 上</span></span><br><span class="line">    doRegister();</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// JDK 底层的 register 操作，将 SocketChannel(或 ServerSocketChannel) 注册到 Selector 中</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，initAndRegister() 算是介绍完了，我们再回过头来看看AbstractBootstrap#bind方法中，除了初始化和注册，还有一个很重要的能力就是绑定。</p>
<h3 id="AbstractBootstrap-doBind0"><a href="#AbstractBootstrap-doBind0" class="headerlink" title="AbstractBootstrap#doBind0"></a>AbstractBootstrap#doBind0</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doBind0</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                <span class="comment">// 调用channel的bind方法，因为此刻channel已经初始化完成了</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，BoosGroup已经创建完毕并且启动完成，开始接收客户端请求的过程了。接收和处理的流程都封装在EventLoop#run 方法中，在下一篇文章中会着重解析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/05/12/Go/Golang%20channel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/05/12/Go/Golang%20channel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Golang channel源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-12 16:56:02" itemprop="dateCreated datePublished" datetime="2023-05-12T16:56:02+08:00">2023-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-07 11:01:00" itemprop="dateModified" datetime="2023-06-07T11:01:00+08:00">2023-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 队列中元素的个数</span></span><br><span class="line">	qcount   <span class="type">uint</span></span><br><span class="line">    <span class="comment">// 环形队列长度，即缓冲区大小</span></span><br><span class="line">	dataqsiz <span class="type">uint</span></span><br><span class="line">    <span class="comment">// 环形队列指针</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">    <span class="comment">// 队列中元素的大小</span></span><br><span class="line">	elemsize <span class="type">uint16</span></span><br><span class="line">    <span class="comment">// 当前通道是否处于关闭状态，创建通道时该字段为0，关闭时字段为1</span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 队列中元素的类型</span></span><br><span class="line">	elemtype *_type</span><br><span class="line">    <span class="comment">// 环形队列中已发送位置索引</span></span><br><span class="line">	sendx    <span class="type">uint</span></span><br><span class="line">    <span class="comment">// 环形队列中已接收位置索引</span></span><br><span class="line">	recvx    <span class="type">uint</span></span><br><span class="line">    <span class="comment">// 等待读消息的groutine队列</span></span><br><span class="line">	recvq    waitq</span><br><span class="line">    <span class="comment">// 等待写消息的groutine队列</span></span><br><span class="line">	sendq    waitq</span><br><span class="line">    <span class="comment">// 互斥锁，为每个读写操作锁定通道</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基础参数校检</span></span><br><span class="line">	<span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">		throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所需buff的大小，buff = （elem.size）* size</span></span><br><span class="line">	mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// size为0，或者每个元素占用的大小为0，这时只需要分配hchan结构体本身占用的大小即可</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// raceaddr内部实现为：return unsafe.Pointer(&amp;c.buf)</span></span><br><span class="line">		c.buf = c.raceaddr()</span><br><span class="line">	<span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// 如果队列中不存在指针，那么每个元素都需要被存储并占用空间，占用大小为前面乘法算出来的mem</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// 把buf指针指向空的hchan占用空间大小的末尾，add内部实现为：return unsafe.Pointer(uintptr(p) + x)</span></span><br><span class="line">		c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 如果chan中的元素是指针类型的数据，为buf单独开辟mem大小的空间，用来保存所有的数据</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 设置元素大小</span></span><br><span class="line">	c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">	<span class="comment">// 设置元素类型</span></span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    <span class="comment">// 环形队列大小</span></span><br><span class="line">	c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">	lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="发送数据到channel"><a href="#发送数据到channel" class="headerlink" title="发送数据到channel"></a>发送数据到channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// channel 的所有操作，都在互斥锁下</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 如果投递的目标是已经关闭的 channel，那么直接 panic；</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 1. 队列中刚好有goroutine在等待，直接给它就完事了（性能最好）</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 递增 sendx, recvx 的索引，然后直接把元素给到等他的人，并且唤醒他</span></span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 2. 环形队列中 还有空间，那么把元素放好，递增索引，就可以返回了</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// 复制，赋值好元素</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        <span class="comment">// 递增索引</span></span><br><span class="line">		c.sendx++</span><br><span class="line">        <span class="comment">// 空间回环</span></span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 递增元素个数</span></span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要阻塞？如果是非阻塞的，那么就直接解锁返回了</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	<span class="comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span></span><br><span class="line">	<span class="comment">// to park on a channel. The window between when this G&#x27;s status</span></span><br><span class="line">	<span class="comment">// changes and when we set gp.activeStackChans is not safe for</span></span><br><span class="line">	<span class="comment">// stack shrinking.</span></span><br><span class="line">	atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">	<span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">	<span class="comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span></span><br><span class="line">	<span class="comment">// stack tracer.</span></span><br><span class="line">	KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up.</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">	closed := !mysg.success</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">if</span> closed &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/05/06/git/%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/05/06/git/%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84Git/" class="post-title-link" itemprop="url">带你认识不一样的Git -- Git内部原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-06 17:25:06" itemprop="dateCreated datePublished" datetime="2023-05-06T17:25:06+08:00">2023-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-09 21:41:57" itemprop="dateModified" datetime="2023-05-09T21:41:57+08:00">2023-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为毕业以来所在的公司基建都比较完善，只需要点点点即可完成需求开发，分支合并等日常工作。所以对Git的认知也仅停留在“会用”的基础层面。</p>
<p>直到来到了一家基建不太完善的公司，日常开发都需要从checkout dev分支开始（：仿佛回到了大学时期 - &#x3D; </p>
<p>随之而来的也是各种问题，“合并之后，我代码怎么丢了？”、“你的merge request有不属于你改动的log，请rebase一下”等等。</p>
<p>终于下定决心要好好学习Git了。</p>
<p>我一直认为，当你需要深入学习某一个知识点时，了解其背后的原理，往往能有事半功倍的效果。</p>
<p>只有当你了解Git背后底层的东西，才能帮你更好的梳理思路。试想一下，你每运行一次Git的高级命令，都知道底层发生了什么事，这样你才是真正的掌握了Git。</p>
<p>让我们从0开始，回想下，你第一次使用Git的时候，使用的是什么命令？相信大部分都是git init吧。</p>
<h2 id="从-git-init-开始"><a href="#从-git-init-开始" class="headerlink" title="从 git init 开始"></a>从 git init 开始</h2><p>新建一个目录，初始化git：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> git_test</span><br><span class="line"><span class="built_in">cd</span> git_test/</span><br><span class="line">git init</span><br><span class="line"><span class="built_in">ls</span> -a </span><br></pre></td></tr></table></figure>
<p>可见，git init之后生成了.git目录。我们来看看该目录下都有些啥吧。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">tree .git/</span><br><span class="line"></span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── fsmonitor-watchman.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── pre-merge-commit.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   ├── pre-receive.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── push-to-checkout.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure>
<p>这个目录包含了几乎所有 Git 存储和操作的对象。而从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，当我们<strong>在上层执行各种Git高级命令时，实际上都是在操作Git的文件对象。</strong> 在本文中我们重点关注objects、refs这两个文件对象即可。</p>
<p>接下来我们模拟日常开发所用到的高级命令，看看这些文件对象有什么变化。</p>
<h2 id="Git对象"><a href="#Git对象" class="headerlink" title="Git对象"></a>Git对象</h2><h3 id="数据对象（blob-object）"><a href="#数据对象（blob-object）" class="headerlink" title="数据对象（blob object）"></a>数据对象（blob object）</h3><p>我们在该目录下创建两个文件，并执行git add 命令，看下会发生什么事？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test1&quot;</span> &gt; test1.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test2&quot;</span> &gt; test2.txt</span><br><span class="line">git add *.txt</span><br></pre></td></tr></table></figure>

<p>这个时候再去.git&#x2F;object目录下，你会发现仓库里多了两个文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tree .git/objects/</span><br><span class="line"></span><br><span class="line">.git/objects/</span><br><span class="line">├── 18</span><br><span class="line">│   └── 0cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">├── a5</span><br><span class="line">│   └── bce3fd2565d8f458555a0c6f42d0504a848bd5</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure>
<p> 这就是开始时 Git 存储内容的方式——一个文件对应一条内容，以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。 校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。</p>
<p>我们来看下这两个文件存储的是什么：</p>
<pre><code>因为git将信息压缩成二进制文件，所以要使用git提供cat-file命令来取回转码前的数据，
-t 可以查看object文件的类型，-p可以查看object文件的具体内容。

git cat-file [-t] [-p] object filename object的名字不用输入全，能唯一区分就好（一般都是6位）
</code></pre>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 180cf8</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">git cat-file -p 180cf8</span><br><span class="line">test2</span><br></pre></td></tr></table></figure>

<p>可见这个文件是一个blob对象，存储的是文件的内容。</p>
<p>此时，Git仓库的结构是：</p>
<p><img src="/blog/img/git/git%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%861.png" alt="img"></p>
<h3 id="树对象（tree-object）"><a href="#树对象（tree-object）" class="headerlink" title="树对象（tree object）"></a>树对象（tree object）</h3><p>执行完git add 命令之后，所有的变更都存储到了暂存区中，这时，我们执行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;feat：初始化commit&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以将变更推送到本地的Git仓库中。<br>当执行完git commit命令之后，让我们来看下.git&#x2F;object目录发生了什么改变：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tree .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">├── 18</span><br><span class="line">│   └── 0cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">├── 35</span><br><span class="line">│   └── ad65e8f91eb6611a3f4a3dad741c8281fb0d08</span><br><span class="line">├── 81</span><br><span class="line">│   └── fa9d1c5348f86326ce5e7a86d11b54c8140d8d</span><br><span class="line">├── a5</span><br><span class="line">│   └── bce3fd2565d8f458555a0c6f42d0504a848bd5</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure>

<p>可见，目录又增加了两个文件。继续探索：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 81fa9d</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">git cat-file -p 81fa9d</span><br><span class="line">100644 blob a5bce3fd2565d8f458555a0c6f42d0504a848bd5	test1.txt</span><br><span class="line">100644 blob 180cf8328022becee9aaa2577a8f84ea2b9f3827	test2.txt</span><br></pre></td></tr></table></figure>

<p>这是树对象，它能解决文件名保存的问题，也允许我们将多个文件组织到一起。一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p>
<p>此时，Git仓库的结构是：</p>
<p><img src="/blog/img/git/git%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%862.png" alt="img"></p>
<h3 id="提交对象（commit-object）"><a href="#提交对象（commit-object）" class="headerlink" title="提交对象（commit object）"></a>提交对象（commit object）</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 35ad65e</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">git cat-file -p 35ad65e</span><br><span class="line">tree 81fa9d1c5348f86326ce5e7a86d11b54c8140d8d</span><br><span class="line">author Yuqiang Lin &lt;yuqiang.lin@xxxx.com&gt; 1683369025 +0800</span><br><span class="line">committer Yuqiang Lin &lt;yuqiang.lin@xxxx.com&gt; 1683369025 +0800</span><br><span class="line"></span><br><span class="line">feat：初始化commit</span><br></pre></td></tr></table></figure>

<p>当执行完git commit命令之后，会生成两种类型的对象：树对象、提交对象。</p>
<p>而提交对象，它储存的是一个提交的信息，包括对应目录结构的快照tree的哈希值，上一个提交的哈希值（这里由于是第一个提交，所以没有父节点。在一个merge提交中还会出现多个父节点），提交的作者以及提交的具体时间，最后是该提交的信息。</p>
<p>此时，Git仓库的结构是：</p>
<p><img src="/blog/img/git/git%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%863.png" alt="img"></p>
<h2 id="Git引用"><a href="#Git引用" class="headerlink" title="Git引用"></a>Git引用</h2><p>至此，我们明白了Git是如何存储数据、提交信息的。但很多同学也许会问，那我们的分支信息存储在哪里呢？</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> .git/refs/heads/master</span><br><span class="line">35ad65e8f91eb6611a3f4a3dad741c8281fb0d08</span><br></pre></td></tr></table></figure>

<p>可见，在Git仓库里面，HEAD、分支、普通的Tag可以简单的理解成是一个指针，指向对应commit的SHA1值。文件位置是：git&#x2F;refs&#x2F;</p>
<p>概括来说：<strong>HEAD里面的内容是当前分支的ref，而当前ref的内容是commit hash，commit object内容是 tree hash，tree object的内容是blob hash，blob存储着文件的具体内容</strong></p>
<p>可以看到，此时Git仓库的结构是：</p>
<p><img src="/blog/img/git/git%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%864.png" alt="img"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>了解了Git的内部原理之后，让我们来看下在日常工作中，我们执行的高级命令之后，对应的底层文件是如何变化的。</p>
<h3 id="切换dev分支开发新feature"><a href="#切换dev分支开发新feature" class="headerlink" title="切换dev分支开发新feature"></a>切换dev分支开发新feature</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">// 修改文件</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;update1&quot;</span> &gt;test1.txt</span><br><span class="line"></span><br><span class="line">// 提交文件</span><br><span class="line">git add test1.txt</span><br><span class="line">git commit -m <span class="string">&quot;feat:dev feature&quot;</span></span><br></pre></td></tr></table></figure>

<p>再看下此时的Git文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tree .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">├── 18</span><br><span class="line">│   └── 0cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">├── 33</span><br><span class="line">│   └── cbe3a0c944e78ea4f141319c5e5e703cda7c94</span><br><span class="line">├── 35</span><br><span class="line">│   └── ad65e8f91eb6611a3f4a3dad741c8281fb0d08</span><br><span class="line">├── 81</span><br><span class="line">│   └── fa9d1c5348f86326ce5e7a86d11b54c8140d8d</span><br><span class="line">├── a5</span><br><span class="line">│   └── bce3fd2565d8f458555a0c6f42d0504a848bd5</span><br><span class="line">├── f1</span><br><span class="line">│   └── 2607f50b9b3f30c012d159d7a5aada4ba64f31</span><br><span class="line">├── f6</span><br><span class="line">│   └── bce7ac1d8060e485087c6ff393f72d1bfe3cb3</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到objects目录下又新增了三个文件，我们依次输出一下新增的三个文件的类型和内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 33cbe3</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">git cat-file -p 33cbe3</span><br><span class="line">update1</span><br><span class="line"></span><br><span class="line">git cat-file -t f12607</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">git cat-file -p f12607</span><br><span class="line">100644 blob 33cbe3a0c944e78ea4f141319c5e5e703cda7c94	test1.txt</span><br><span class="line">100644 blob 180cf8328022becee9aaa2577a8f84ea2b9f3827	test2.txt</span><br><span class="line"></span><br><span class="line">git cat-file -t f6bce7</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">git cat-file -p f6bce7</span><br><span class="line">tree f12607f50b9b3f30c012d159d7a5aada4ba64f31</span><br><span class="line">parent 35ad65e8f91eb6611a3f4a3dad741c8281fb0d08</span><br><span class="line">author Yuqiang Lin &lt;yuqiang.lin@xxx.com&gt; 1683378308 +0800</span><br><span class="line">committer Yuqiang Lin &lt;yuqiang.lin@xxx.com&gt; 1683378308 +0800</span><br><span class="line"></span><br><span class="line">feat:dev feature</span><br></pre></td></tr></table></figure>

<p>依次多了blob object，tree object和commit object，因为我们并没有修改test2.txt文件的内容，所以仓库里和test2.txt有关的blob object依旧是之前的那一个。</p>
<p>再看一下此刻的HEAD和refs下的内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tree .git/refs/</span><br><span class="line">.git/refs/</span><br><span class="line">├── heads</span><br><span class="line">│   ├── dev</span><br><span class="line">│   └── master</span><br><span class="line">└── tags</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span>  .git/refs/heads/dev</span><br><span class="line">f6bce7ac1d8060e485087c6ff393f72d1bfe3cb3</span><br></pre></td></tr></table></figure>

<p>refs目录下增加了对应的heads&#x2F;dev文件，记录的是我们新生成的commit object Hash，HEAD里的内容也变成了当前分支：dev。</p>
<p>此时，Git仓库的结构是：</p>
<p><img src="/blog/img/git/git%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%865.png" alt="img"></p>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 切换到master分支</span><br><span class="line">git checkout master</span><br><span class="line">// 修改文件</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;update2&quot;</span> &gt;test1.txt</span><br><span class="line">git add test1.txt</span><br><span class="line">git commit -m <span class="string">&quot;feat: master update&quot;</span></span><br><span class="line"></span><br><span class="line">tree .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">├── 18</span><br><span class="line">│   └── 0cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">├── 33</span><br><span class="line">│   └── cbe3a0c944e78ea4f141319c5e5e703cda7c94</span><br><span class="line">├── 35</span><br><span class="line">│   └── ad65e8f91eb6611a3f4a3dad741c8281fb0d08</span><br><span class="line">├── 3c</span><br><span class="line">│   └── e1c4fbb311aace4a9788e81fb531579b32d92b</span><br><span class="line">├── 7c</span><br><span class="line">│   └── f7ba716667152f96370730cdc8bdb055f830d2</span><br><span class="line">├── 81</span><br><span class="line">│   └── fa9d1c5348f86326ce5e7a86d11b54c8140d8d</span><br><span class="line">├── a5</span><br><span class="line">│   └── bce3fd2565d8f458555a0c6f42d0504a848bd5</span><br><span class="line">├── e3</span><br><span class="line">│   └── 688c1e658d400927092bc903ea0ac007bc664a</span><br><span class="line">├── f1</span><br><span class="line">│   └── 2607f50b9b3f30c012d159d7a5aada4ba64f31</span><br><span class="line">├── f6</span><br><span class="line">│   └── bce7ac1d8060e485087c6ff393f72d1bfe3cb3</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure>
<p>commit 之后依然多了blob object，tree object和commit object三个对象文件。</p>
<p>此时master指向新的commit对象：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>  .git/refs/heads/master</span><br><span class="line">3ce1c4fbb311aace4a9788e81fb531579b32d92b</span><br></pre></td></tr></table></figure>
<p>Git仓库的结构是：</p>
<p><img src="/blog/img/git/git%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%866.png" alt="img"></p>
<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>先切换到dev分支，修改文件，再提交。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;update3&quot;</span> &gt;test2.txt</span><br><span class="line">git add test2.txt</span><br><span class="line">git commit -m <span class="string">&quot;feat: dev update v2&quot;</span></span><br></pre></td></tr></table></figure>

<p>此时，Git仓库的结构是：</p>
<p><img src="/blog/img/git/git%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%867.png" alt="img"></p>
<p>合并master</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge master</span><br></pre></td></tr></table></figure>

<p>解决完冲突提交后，可以看到现在dev分支的指针指向了新的commit对象节点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>  .git/refs/heads/dev</span><br><span class="line">ab2511c51be6aeb126281c2ac48592bd41e5dae6</span><br></pre></td></tr></table></figure>

<p>再看下该commit对象的内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p ab2511c51be6aeb126281c2ac48592bd41e5dae6</span><br><span class="line">tree 4866ff1c6e1a703745c307cc226804e08fdce35c</span><br><span class="line">parent 19a14dc09b813e0bce32cc498cdc318824a51853</span><br><span class="line">parent 3ce1c4fbb311aace4a9788e81fb531579b32d92b</span><br><span class="line">author Yuqiang Lin &lt;yuqiang.lin@shopee.com&gt; 1683382523 +0800</span><br><span class="line">committer Yuqiang Lin &lt;yuqiang.lin@shopee.com&gt; 1683382523 +0800</span><br><span class="line"></span><br><span class="line">feat: merge master</span><br></pre></td></tr></table></figure>

<p>此时dev分支指向的commit对象有两个parent指针，分别指向旧的dev指向commit对象以及master指向的commit对象。<br>其结构是：</p>
<p><img src="/blog/img/git/git%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%868.png" alt="img"></p>
<p>再切回master 分支，合并dev分支（模拟工作中的remote merge request）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure>

<p>可以看到master和dev分支都指向同一个commit对象（Fast-foward模式的合并策略）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>  .git/refs/heads/master</span><br><span class="line">ab2511c51be6aeb126281c2ac48592bd41e5dae6</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span>  .git/refs/heads/dev</span><br><span class="line">ab2511c51be6aeb126281c2ac48592bd41e5dae6</span><br></pre></td></tr></table></figure>
<p>此时结构是：</p>
<p><img src="/blog/img/git/git%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%869.png" alt="img"></p>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>我们将HEAD reset到3ce1c4f这个commit对象中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">ab2511c (HEAD -&gt; master, dev) HEAD@&#123;0&#125;: merge dev: Fast-forward</span><br><span class="line">3ce1c4f HEAD@&#123;1&#125;: checkout: moving from dev to master</span><br><span class="line">ab2511c (HEAD -&gt; master, dev) HEAD@&#123;2&#125;: commit (merge): feat: merge master</span><br><span class="line">19a14dc HEAD@&#123;3&#125;: commit: feat: dev update v2</span><br><span class="line">f6bce7a HEAD@&#123;4&#125;: checkout: moving from master to dev</span><br><span class="line">3ce1c4f HEAD@&#123;5&#125;: commit: feat: master update</span><br><span class="line">35ad65e HEAD@&#123;6&#125;: checkout: moving from dev to master</span><br><span class="line">f6bce7a HEAD@&#123;7&#125;: commit: feat:dev feature</span><br><span class="line">35ad65e HEAD@&#123;8&#125;: checkout: moving from master to dev</span><br><span class="line">35ad65e HEAD@&#123;9&#125;: commit (initial): feat：初始化commit</span><br><span class="line"></span><br><span class="line">git reset --hard 3ce1c4f</span><br><span class="line">HEAD is now at 3ce1c4f feat: master update</span><br></pre></td></tr></table></figure>
<p>此时master分支的指向是：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>  .git/refs/heads/master</span><br><span class="line">3ce1c4fbb311aace4a9788e81fb531579b32d92b</span><br></pre></td></tr></table></figure>
<p>可见此时Git的引用对象已经指向了3ce1c4f。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，模拟了部分常用的Git命令，运行之后，可以看到对应的底层文件变化。印证了上文提到的当我们<strong>在上层执行各种Git高级命令时，实际上都是在操作Git的文件对象。</strong></p>
<p>大家可以继续尝试去使用其他的高级命令，再观察对应的文件变化，相信你会有不一样的体验。</p>
<p>曾就职于拼多多，前蚂蚁金服高级Java开发。平时会分享些工作中遇到的技术问题，包括但不限于Java、分布式、大数据。也会分享些理财笔记。关注公众号，了解更多~</p>
<p><img src="/blog/img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpeg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/05/05/kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/%E3%80%8CKafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6%E3%80%8D%E4%B9%8BConsumer%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/05/05/kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/%E3%80%8CKafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6%E3%80%8D%E4%B9%8BConsumer%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">post</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-05 18:07:38 / 修改时间：22:41:45" itemprop="dateCreated datePublished" datetime="2023-05-05T18:07:38+08:00">2023-05-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/04/30/kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/%E3%80%8CKafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6%E3%80%8D%E4%B9%8BBufferPool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/04/30/kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/%E3%80%8CKafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6%E3%80%8D%E4%B9%8BBufferPool/" class="post-title-link" itemprop="url">「Kafka源码美学」之BufferPool</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-30 19:11:43" itemprop="dateCreated datePublished" datetime="2023-04-30T19:11:43+08:00">2023-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-05 22:41:42" itemprop="dateModified" datetime="2023-05-05T22:41:42+08:00">2023-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">Kafka源码美学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章我们来重点分析producer端一个重要组件：BufferPool。</p>
<p>在Kafka中，BufferPool是用于缓存和管理内存的数据结构。当Kafka需要内存时，它会向BufferPool请求内存，BufferPool会根据内存大小的需求，从合适的内存池中获取内存，并将内存块返回给Kafka。</p>
<p>BufferPool有两个关键参数：</p>
<ol>
<li>buffer.memory：指定缓冲池的大小，默认是32m</li>
<li>batch.size：内存块的大小，默认是16k</li>
</ol>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/blog/img/kafka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/BufferPool.png" alt="img"></p>
<p>缓冲池的持有类是 BufferPool，我们先来看下 BufferPool 的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferPool</span> &#123;</span><br><span class="line">  <span class="comment">// 总的内存大小，即buffer.memory</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> totalMemory;</span><br><span class="line">  <span class="comment">// 每个内存块大小，即 batch.size</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolableSize;</span><br><span class="line">  <span class="comment">// 申请、归还内存的方法的同步锁</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">  <span class="comment">// 空闲的内存块</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; free;</span><br><span class="line">  <span class="comment">// 需要等待空闲内存块的事件</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Condition&gt; waiters;</span><br><span class="line">  <span class="comment">/** Total available memory is the sum of nonPooledAvailableMemory and the number of byte buffers in free * poolableSize.  */</span></span><br><span class="line">  <span class="comment">// “未被池化的可使用空间”，新申请的内存块就是从这里获取内存值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> nonPooledAvailableMemory;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来跟大家一起分析申请内存和归还内存是如何实现的。</p>
<h2 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h2><p>在分析RecordAccumulator 文章中可知，当需要新申请一个producerBatch时，需要申请一个内存块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 到这里则表明需要新申请producerBatch，用来存储新数据</span></span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 从BufferPool申请ByteBuffer。如果BufferPool空间不足就轮询等待。</span></span><br><span class="line">    buffer = free.allocate(size, maxTimeToBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见申请内存的入口是：</p>
<p><strong>org.apache.kafka.clients.producer.internals.BufferPool#allocate</strong></p>
<p>分析其源码：</p>
<h3 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Params:</span></span><br><span class="line"><span class="comment">    size – 代表将要分配的内存空间 </span></span><br><span class="line"><span class="comment">    maxTimeToBlockMs – 代表如果现在空间不足以分配，最大的block时长。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> size, <span class="type">long</span> maxTimeToBlockMs)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里先判断下所需要分配的内存空间是不是超过了最大容量，如果超过了，直接抛异常结束</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="built_in">this</span>.totalMemory)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="comment">// 最终分配出来的buffer对象</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 先上锁，代表同一时刻只能有一个线程在分配内存</span></span><br><span class="line">        <span class="built_in">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当申请的内存大小恰好等于poolableSize，且free队列中存在空闲内存块，则直接分配。参见note 1</span></span><br><span class="line">            <span class="keyword">if</span> (size == poolableSize &amp;&amp; !<span class="built_in">this</span>.free.isEmpty())</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.free.pollFirst();</span><br><span class="line">            <span class="comment">// 计算剩余的内存大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">freeListSize</span> <span class="operator">=</span> freeSize() * <span class="built_in">this</span>.poolableSize;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.nonPooledAvailableMemory + freeListSize &gt;= size) &#123;</span><br><span class="line">                <span class="comment">// 走到这儿，代表现在剩余的内存空间是够的，那么接下来的freeUp方法所要做事情就是要凑出来一个size大小的内存空间</span></span><br><span class="line">                freeUp(size);</span><br><span class="line">                <span class="comment">// 在nonPooledAvailableMemory中减去已分配的size内存空间，具体分配ByteBuffer的操作是在finally块中完成的</span></span><br><span class="line">                <span class="built_in">this</span>.nonPooledAvailableMemory -= size;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 走到这里，代表BufferPool中剩余的内存已经不足以分配了，现在需要阻塞待分配的线程，等待内存回收。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 已回收的内存大小，参见note 2</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">accumulated</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 创建一个等待的Condition对象</span></span><br><span class="line">                <span class="type">Condition</span> <span class="variable">moreMemory</span> <span class="operator">=</span> <span class="built_in">this</span>.lock.newCondition();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 添加到等待者尾部</span></span><br><span class="line">                    <span class="built_in">this</span>.waiters.addLast(moreMemory);</span><br><span class="line">                    <span class="keyword">while</span> (accumulated &lt; size) &#123;</span><br><span class="line">                        <span class="comment">// 如果free中已回收到内存块，且待分配的内存大小等于poolableSize，则直接分配</span></span><br><span class="line">                        <span class="keyword">if</span> (accumulated == <span class="number">0</span> &amp;&amp; size == <span class="built_in">this</span>.poolableSize &amp;&amp; !<span class="built_in">this</span>.free.isEmpty()) &#123;</span><br><span class="line">                            buffer = <span class="built_in">this</span>.free.pollFirst();</span><br><span class="line">                            accumulated = size;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//  否则，不管当前需要的空间大小是不是poolableSize，都得从nonPooledAvailableMemory中向外划分</span></span><br><span class="line">                            freeUp(size - accumulated);</span><br><span class="line">                            <span class="comment">// 给当前线程分配空间，如果所分配的</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">got</span> <span class="operator">=</span> (<span class="type">int</span>) Math.min(size - accumulated, <span class="built_in">this</span>.nonPooledAvailableMemory);</span><br><span class="line">                            <span class="built_in">this</span>.nonPooledAvailableMemory -= got;</span><br><span class="line">                            accumulated += got;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 跳出循环，说明此时我们已经给这个线程的需求分配了所需的内存空间，将accumulated置0</span></span><br><span class="line">                    accumulated = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 内层的finally块，对while循环进行保护，无论代码块中是否出现异常（异常代码并不是主流程，在本文中已忽略）都需要做一些重置工作，因为循环中会修改相关成员变量</span></span><br><span class="line">                    <span class="built_in">this</span>.nonPooledAvailableMemory += accumulated;</span><br><span class="line">                    <span class="built_in">this</span>.waiters.remove(moreMemory);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前还有内存可用，且还有waiter在等待，那么继续唤醒下一个waiter。</span></span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">this</span>.nonPooledAvailableMemory == <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.free.isEmpty()) &amp;&amp; !<span class="built_in">this</span>.waiters.isEmpty())</span><br><span class="line">                    <span class="built_in">this</span>.waiters.peekFirst().signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 经过上面的一通操作可知，除了待分配的内存大小等于poolableSize，并且free中正好有一个buffer可用的情况，其余从nonPooledAvailableMemory分配内存，就只是减去了一个数量，还没有实际分配。</span></span><br><span class="line">        <span class="keyword">if</span> (buffer == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 进行实际的分配操作</span></span><br><span class="line">            <span class="keyword">return</span> safeAllocateByteBuffer(size);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><ol>
<li><p>申请内存大小的size是在 org.apache.kafka.clients.producer.internals.RecordAccumulator#append 中计算的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="built_in">this</span>.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(maxUsableMagic, compression, key, value, headers));</span><br></pre></td></tr></table></figure>
<p>这块内存的大小只有两种情况：</p>
<ol>
<li>如果申请的内存小于batch.size（默认16KB），那么分配一个batch.size大小的ByteBuffer</li>
<li>如果申请的内存大于了batch.size，那么就按需分配一块正好的内存</li>
</ol>
</li>
<li><p>accumulated：如果我们要分配一个比较大的内存空间，而BufferPool剩余的内存不够，所以需要等着内存慢慢回收回来。但是不一定一次就都回收回来，所以每次回收一点这个值就加一点，直到accumulated达到了size大小，认为内存已经回收够了</p>
</li>
</ol>
<p>接下来看下freeUp和safeAllocateByteBuffer方法</p>
<h3 id="freeUp"><a href="#freeUp" class="headerlink" title="freeUp"></a>freeUp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 如果nonPooledAvailableMemory &gt; size，那么方法都不会执行，因为本身剩余的空间就够分配size大小的内存空间了</span></span><br><span class="line"><span class="comment">    2. 但是如果nonPooledAvailableMemory不够了，就需要把free队列中的一些ByteBuffer让出来增加nonPooledAvailableMemory的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">freeUp</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.free.isEmpty() &amp;&amp; <span class="built_in">this</span>.nonPooledAvailableMemory &lt; size)</span><br><span class="line">        <span class="comment">// 将一个ByteBuffer从列表中移除（本来分配的也是堆上内存，所以会被GC），然后将让出来的这部分空间大小加到nonPooledAvailableMemory上</span></span><br><span class="line">        <span class="built_in">this</span>.nonPooledAvailableMemory += <span class="built_in">this</span>.free.pollLast().capacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="safeAllocateByteBuffer"><a href="#safeAllocateByteBuffer" class="headerlink" title="safeAllocateByteBuffer"></a>safeAllocateByteBuffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ByteBuffer <span class="title function_">safeAllocateByteBuffer</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">error</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用Java Nio方法申请ByteBuffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> allocateByteBuffer(size);</span><br><span class="line">            error = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> buffer;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                <span class="comment">// 如果分配内存没有分配成功，需要重置nonPooledAvailableMemory和waiters，所以又要加锁了</span></span><br><span class="line">                <span class="built_in">this</span>.lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.nonPooledAvailableMemory += size;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">this</span>.waiters.isEmpty())</span><br><span class="line">                        <span class="built_in">this</span>.waiters.peekFirst().signal();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="归还内存"><a href="#归还内存" class="headerlink" title="归还内存"></a>归还内存</h2><p>当内存块使用完毕后，需要归还给BufferPool。</p>
<p>归还内存的入口是：<strong>org.apache.kafka.clients.producer.internals.BufferPool#deallocate</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deallocate</span><span class="params">(ByteBuffer buffer, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当归还的内存大小等于poolableSize，证明是可复用ByteBuffer，将其添加到free 队列中</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="built_in">this</span>.poolableSize &amp;&amp; size == buffer.capacity()) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="built_in">this</span>.free.add(buffer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则将内存大小累加到nonPooledAvailableMemory即可，内存无需归还，让其被JVM GC 回收掉。</span></span><br><span class="line">            <span class="built_in">this</span>.nonPooledAvailableMemory += size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后唤醒正在等待的线程，让其重新申请内存</span></span><br><span class="line">        <span class="type">Condition</span> <span class="variable">moreMem</span> <span class="operator">=</span> <span class="built_in">this</span>.waiters.peekFirst();</span><br><span class="line">        <span class="keyword">if</span> (moreMem != <span class="literal">null</span>)</span><br><span class="line">            moreMem.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上的源码分析，如果batch.size设置不当有可能导致严重的性能影响。</p>
<ol>
<li>如果业务消息体的内存大小比batchSize要大，则不会从free队列中获取内存块，而是重新创建一个新的ByteBuffer，使用完毕后也不会归还到BufferPool，直接被GC回收。</li>
<li>当nonPooledAvailableMemory比消息体还要小时，会将free中的内存块回收，以便腾出足够空间让用户申请。</li>
</ol>
<p>因此，我们在使用时，需要根据业务消息的大小，适当调整 batch.size 的大小，避免频繁 GC。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>曾就职于拼多多，前蚂蚁金服高级Java开发。平时会分享些工作中遇到的技术问题，包括但不限于Java、分布式、大数据。也会分享些理财笔记。关注公众号，了解更多~</p>
<p><img src="/blog/img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpeg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/04/29/kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/%E3%80%8CKafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6%E3%80%8D%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%8F%91%E9%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/04/29/kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/%E3%80%8CKafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6%E3%80%8D%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%8F%91%E9%80%81/" class="post-title-link" itemprop="url">「Kafka源码美学」之网络发送</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-29 23:45:25" itemprop="dateCreated datePublished" datetime="2023-04-29T23:45:25+08:00">2023-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-09 10:06:42" itemprop="dateModified" datetime="2023-05-09T10:06:42+08:00">2023-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">Kafka源码美学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过「Kafka源码美学」之Sender线程文章中，我们知道Sender最终把消息发送出去，依靠的是Kafka核心组件 - NetWorkClient。它负责Kafka所有的网络IO，包括连接的建立，读数据、写数据等等。</p>
<p>而NetworkClient是基于Java Nio封装的，所以在阅读本文前需要了解Java Nio的基础知识。</p>
<p>让我们先来看看网络发送的流程图吧：</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/blog/img/kafka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/kafka%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1.png" alt="img"></p>
<p>上面流程图是Kafka producer网络层的主体流程，结合之前的文章，相信你能有一个大体的印象。</p>
<p>Kafka的网络层是基于Java NIO封装的。<br>Kafka中针对NIO的Selector的封装类也叫Selector，对Channel的封装类叫做KafkaChannel。注意这里需要区分两个Selector</p>
<ol>
<li>Kafka的Selector：org.apache.kafka.common.network.Selector</li>
<li>Java的Selector：java.nio.channels.Selector</li>
</ol>
<p>首先看下NetworkClient的核心字段解释。</p>
<h2 id="核心字段"><a href="#核心字段" class="headerlink" title="核心字段"></a>核心字段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaChannel</span> &#123;</span><br><span class="line">  <span class="comment">//继承java.nio.channels.Channel，可读可写,对socketChannel的封装</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransportLayer transportLayer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过它来创建Buffer和回收Buffer</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MemoryPool memoryPool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//收到的数据</span></span><br><span class="line">  <span class="keyword">private</span> NetworkReceive receive;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送的数据</span></span><br><span class="line">  <span class="keyword">private</span> Send send;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selector</span> <span class="keyword">implements</span> <span class="title class_">Selectable</span>, AutoCloseable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//java nio中的Selector</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> java.nio.channels.Selector nioSelector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//kafka服务器节点和Channel之间对应关系</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, KafkaChannel&gt; channels;</span><br><span class="line">  <span class="comment">//发送完成的请求</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Send&gt; completedSends;</span><br><span class="line">  <span class="comment">//完整的消息响应</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;NetworkReceive&gt; completedReceives;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//暂存的消息响应</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;KafkaChannel, Deque&lt;NetworkReceive&gt;&gt; stagedReceives;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//立即连接上的SelectionKey</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; immediatelyConnectedKeys;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用于分配ByteBuffer</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MemoryPool memoryPool;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下里我们来看看具体的源码实现。</p>
<h2 id="消息预发送"><a href="#消息预发送" class="headerlink" title="消息预发送"></a>消息预发送</h2><p>由「Kafka源码美学」之Sender线程文章中知道，sender线程调用KafkaClient.send()，将待发送的数据暂存到队列中，等待触发网络IO完成发送。核心的实现在doSend()方法中</p>
<h3 id="KafkaClient-doSend"><a href="#KafkaClient-doSend" class="headerlink" title="KafkaClient.doSend()"></a>KafkaClient.doSend()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSend</span><span class="params">(ClientRequest clientRequest, <span class="type">boolean</span> isInternalRequest, <span class="type">long</span> now, AbstractRequest request)</span> &#123;</span><br><span class="line">     <span class="comment">// 获取请求目标地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">destination</span> <span class="operator">=</span> clientRequest.destination();</span><br><span class="line">    <span class="comment">// 构造请求头</span></span><br><span class="line">    <span class="type">RequestHeader</span> <span class="variable">header</span> <span class="operator">=</span> clientRequest.makeHeader(request.version());</span><br><span class="line">     <span class="comment">// 将请求对象转换成网络发送对象</span></span><br><span class="line">    <span class="type">Send</span> <span class="variable">send</span> <span class="operator">=</span> request.toSend(header);</span><br><span class="line">    <span class="comment">// 构造待发送请求对象</span></span><br><span class="line">    <span class="type">InFlightRequest</span> <span class="variable">inFlightRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InFlightRequest</span>(</span><br><span class="line">            clientRequest,</span><br><span class="line">            header,</span><br><span class="line">            isInternalRequest,</span><br><span class="line">            request,</span><br><span class="line">            send,</span><br><span class="line">            now);</span><br><span class="line">    <span class="comment">// 添加到发送队列</span></span><br><span class="line">    <span class="built_in">this</span>.inFlightRequests.add(inFlightRequest);</span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    selector.send(<span class="keyword">new</span> <span class="title class_">NetworkSend</span>(clientRequest.destination(), send));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要的步骤包括：构造请求头部，将请求对象转换成网络发送对象，构造待发送请求对象，并将其添加到发送队列中，最后发送请求给Broker端。其中，InFlightRequest对象表示待发送的请求对象，NetworkSend对象表示网络发送对象。</p>
<h3 id="Selector-send"><a href="#Selector-send" class="headerlink" title="Selector.send()"></a>Selector.send()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送网络发送对象给Broker端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> send 网络发送对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(NetworkSend send)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取目标地址的连接ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">connectionId</span> <span class="operator">=</span> send.destinationId();</span><br><span class="line">    <span class="comment">// 获取或创建连接通道</span></span><br><span class="line">    <span class="type">KafkaChannel</span> <span class="variable">channel</span> <span class="operator">=</span> openOrClosingChannelOrFail(connectionId);</span><br><span class="line">    <span class="keyword">if</span> (closingChannels.containsKey(connectionId)) &#123; </span><br><span class="line">        <span class="comment">// 如果连接通道正在关闭，则将其添加到failedSends中等待处理</span></span><br><span class="line">        <span class="built_in">this</span>.failedSends.add(connectionId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 否则将网络发送对象设置到连接通道上</span></span><br><span class="line">            channel.setSend(send);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看到调用了 KafkaChannel 类的 setSend() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSend</span><span class="params">(Send send)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.send != <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Attempt to begin a send operation with prior send operation still in progress, connection id is &quot;</span> + id);</span><br><span class="line">  <span class="comment">// 设置要发送消息的字段</span></span><br><span class="line">  <span class="built_in">this</span>.send = send;</span><br><span class="line">  <span class="comment">// 调用传输层增加写事件</span></span><br><span class="line">  <span class="built_in">this</span>.transportLayer.addInterestOps(SelectionKey.OP_WRITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterestOps</span><span class="params">(<span class="type">int</span> ops)</span> &#123;</span><br><span class="line">    <span class="comment">//通过 key.interestOps() | ops 来添加事件</span></span><br><span class="line">    key.interestOps(key.interestOps() | ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要作用是在发送网络请求之前，将需要发送的ByteBuffer数据保存到KafkaChannel对象的send字段中，然后调用传输层方法注册该通道对「OP_WRITE」事件的关注，同时保留「OP_READ」事件，因此此时该通道是可以同时进行读写操作的。当真正执行发送时，将从send字段中读取数据发送。因此，该方法实现了预先将待发送数据写入缓存，等待网络传输的功能。</p>
<h2 id="消息真正发送"><a href="#消息真正发送" class="headerlink" title="消息真正发送"></a>消息真正发送</h2><p>在分析sender线程的文章中提到，消息真正发送的链路是：<br>Sender.run() -&gt; NetworkClient.poll() -&gt; KSelector.poll() –&gt; nioSelector.select()</p>
<p>让我们来看下KSelector.poll()：</p>
<h3 id="Selector-poll"><a href="#Selector-poll" class="headerlink" title="Selector.poll()"></a>Selector.poll()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 调用nioSelector.select线程阻塞等待I/O事件并设置阻塞时间，等待I/O事件就绪发生，然后返回已经监控到了多少准备就绪的事件</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numReadyKeys</span> <span class="operator">=</span> select(timeout);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">dataInBuffers</span> <span class="operator">=</span> !keysWithBufferedRead.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听到事件发生</span></span><br><span class="line">    <span class="keyword">if</span> (numReadyKeys &gt; <span class="number">0</span> || !immediatelyConnectedKeys.isEmpty() || dataInBuffers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataInBuffers) &#123;</span><br><span class="line">            <span class="comment">// 处理缓冲数据轮训事件</span></span><br><span class="line">            pollSelectionKeys(toPoll, <span class="literal">false</span>, endSelect);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理处理就绪事件</span></span><br><span class="line">        pollSelectionKeys(readyKeys, <span class="literal">false</span>, endSelect);</span><br><span class="line">        <span class="comment">// 处理立即连接集合</span></span><br><span class="line">        pollSelectionKeys(immediatelyConnectedKeys, <span class="literal">true</span>, endSelect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 poll() 方法中，pollSelectionKeys方法会调用三次：</p>
<ol>
<li>处理从具有缓冲数据的通道的轮询事件</li>
<li>处理已经就绪的事件，进行相应的 IO 操作。</li>
<li>处理新建立的那些连接，添加缓存及传输层的握手与认证。</li>
</ol>
<p>Selector.select() 方法底层还是调用的 Java NIO 的原生接口，这里的 nioSelector 其实就是 java.nio.channels.Selector 的实例对象，这个方法最坏情况下，会阻塞 ms 的时间，如果在一次轮询，只要有一个 Channel 的事件就绪，它就会立马返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">long</span> timeoutMs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeoutMs &lt; <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout should be &gt;= 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeoutMs == <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.nioSelector.selectNow();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.nioSelector.select(timeoutMs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看pollSelectionKeys()方法</p>
<h3 id="Selector-pollSelectionKeys"><a href="#Selector-pollSelectionKeys" class="headerlink" title="Selector.pollSelectionKeys()"></a>Selector.pollSelectionKeys()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">pollSelectionKeys</span><span class="params">(Set&lt;SelectionKey&gt; selectionKeys,</span></span><br><span class="line"><span class="params">                       <span class="type">boolean</span> isImmediatelyConnected,</span></span><br><span class="line"><span class="params">                       <span class="type">long</span> currentTimeNanos)</span> &#123;</span><br><span class="line">  <span class="comment">// 循环调用当前监听到的事件</span></span><br><span class="line">  <span class="keyword">for</span> (SelectionKey key : determineHandlingOrder(selectionKeys)) &#123;</span><br><span class="line">    <span class="comment">// 之前创建连接，把kafkachanel注册到key上，这里就是获取对应的 channel</span></span><br><span class="line">    <span class="type">KafkaChannel</span> <span class="variable">channel</span> <span class="operator">=</span> channel(key);</span><br><span class="line">    <span class="comment">// 判断channel是否就绪，有可读数据，未完成接收，则尝试处理读事件</span></span><br><span class="line">    <span class="keyword">if</span> (channel.ready() &amp;&amp; (key.isReadable() || channel.hasBytesBuffered()) &amp;&amp; !hasCompletedReceive(channel) &amp;&amp; !explicitlyMutedChannels.contains(channel)) &#123;</span><br><span class="line">        <span class="comment">// 尝试处理读事件</span></span><br><span class="line">        attemptRead(channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试处理写事件</span></span><br><span class="line">        attemptWrite(key, channel, nowNanos);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="attemptRead"><a href="#attemptRead" class="headerlink" title="attemptRead"></a>attemptRead</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attemptWrite</span><span class="params">(SelectionKey key, KafkaChannel channel, <span class="type">long</span> nowNanos)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// 满足条件进行写操作</span></span><br><span class="line">   <span class="keyword">if</span> (channel.hasSend()</span><br><span class="line">                &amp;&amp; channel.ready()</span><br><span class="line">                &amp;&amp; key.isWritable()</span><br><span class="line">                &amp;&amp; !channel.maybeBeginClientReauthentication(() -&gt; nowNanos)) &#123;</span><br><span class="line">        write(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="attemptRead-1"><a href="#attemptRead-1" class="headerlink" title="attemptRead"></a>attemptRead</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(KafkaChannel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">nodeId</span> <span class="operator">=</span> channel.id();</span><br><span class="line">    <span class="comment">// 将保存在 send 上的数据真正发送出去，但是一次不一定能发送完，会返回已经发出的字节数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">bytesSent</span> <span class="operator">=</span> channel.write();</span><br><span class="line">    <span class="comment">// 判断是否发送完成，未完成返回null，等待下次poll继续发送</span></span><br><span class="line">    <span class="type">NetworkSend</span> <span class="variable">send</span> <span class="operator">=</span> channel.maybeCompleteSend();</span><br><span class="line">    <span class="keyword">if</span> (bytesSent &gt; <span class="number">0</span> || send != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送完成</span></span><br><span class="line">        <span class="keyword">if</span> (send != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 send 添加到 completedSends</span></span><br><span class="line">            <span class="built_in">this</span>.completedSends.add(send);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要用来真正执行网络写操作。</p>
<h3 id="KafkaChannel-write"><a href="#KafkaChannel-write" class="headerlink" title="KafkaChannel.write()"></a>KafkaChannel.write()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 判断 send 是否为空，如果为空表示已经发送完毕了</span></span><br><span class="line">    <span class="keyword">if</span> (send == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    midWrite = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 调用ByteBufferSend.writeTo把数据真正发送出去</span></span><br><span class="line">    <span class="keyword">return</span> send.writeTo(transportLayer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ByteBufferSend-writeTo"><a href="#ByteBufferSend-writeTo" class="headerlink" title="ByteBufferSend.writeTo"></a>ByteBufferSend.writeTo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数据写入传输通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeTo</span><span class="params">(TransferableChannel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 通过传输通道写入数据到缓冲区中</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">written</span> <span class="operator">=</span> channel.write(buffers);</span><br><span class="line">    <span class="keyword">if</span> (written &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>(<span class="string">&quot;Wrote negative bytes to channel. This shouldn&#x27;t happen.&quot;</span>);</span><br><span class="line">    <span class="comment">// 更新缓冲区中剩余数据的字节数</span></span><br><span class="line">    remaining -= written;</span><br><span class="line">    <span class="comment">// 检查传输通道是否有未写入的数据</span></span><br><span class="line">    pending = channel.hasPendingWrites();</span><br><span class="line">    <span class="comment">// 返回已写入的字节数</span></span><br><span class="line">    <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要用来把 buffers 数组写入到 SocketChannel 里，因为在网络编程中，写一次不一定可以完全把数据都写成功，所以调用java nio 底层 channel.write(buffers) 方法会返回「已经写入成功多少字节」的返回值，这样调用一次后就知道已经写入多少字节了。</p>
<h3 id="maybeCompleteSend"><a href="#maybeCompleteSend" class="headerlink" title="maybeCompleteSend"></a>maybeCompleteSend</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Send <span class="title function_">maybeCompleteSend</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// send 不为空且已经发送完毕</span></span><br><span class="line">    <span class="keyword">if</span> (send != <span class="literal">null</span> &amp;&amp; send.completed()) &#123;</span><br><span class="line">        midWrite = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 当写数据完毕后，取消传输层对 OP_WRITE 事件的监听，完成一次写操作</span></span><br><span class="line">        transportLayer.removeInterestOps(SelectionKey.OP_WRITE);</span><br><span class="line">        <span class="comment">// 将 send 赋值给结果集 result</span></span><br><span class="line">        <span class="type">Send</span> <span class="variable">result</span> <span class="operator">=</span> send;</span><br><span class="line">        <span class="comment">// 此时读完后将 send 清空，以便下次写</span></span><br><span class="line">        send = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 最后返回结果集 result，完成一次写操作</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，终于将message 发送到了broker中，让我们来总结一下消息发送的流程</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>产生一条消息，由Producer.send()会以ProducerBatch为单位追加到RecordAccumulator中，sender线程不断读取RecordAccumulator中的数据，包装成ClientRequest，然后调用NetworkClient的接口，发送到broker中</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>曾就职于拼多多，前蚂蚁金服高级Java开发。平时会分享些工作中遇到的技术问题，包括但不限于Java、分布式、大数据。也会分享些理财笔记。关注公众号，了解更多~</p>
<p><img src="/blog/img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpeg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/04/28/kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/%E3%80%8CKafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6%E3%80%8D%E4%B9%8BSender%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/04/28/kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/%E3%80%8CKafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6%E3%80%8D%E4%B9%8BSender%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">「Kafka源码美学」之Sender线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-28 17:22:00" itemprop="dateCreated datePublished" datetime="2023-04-28T17:22:00+08:00">2023-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-06 10:10:45" itemprop="dateModified" datetime="2023-05-06T10:10:45+08:00">2023-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Kafka%E6%BA%90%E7%A0%81%E7%BE%8E%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">Kafka源码美学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>回顾之前文章的架构图：</p>
<p><img src="/blog/img/kafka%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/%E7%94%9F%E4%BA%A7%E8%80%85%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="img"></p>
<p>可知Sender线程扮演中间层的角色，对上承接RecordAccumulator，获取待发送的ProducerBatch，对下调用网络IO，实现真正的网络请求。<br>需要注意的是，<strong>Sender线程是一个单线程</strong>，所以它所有的方法都是线程安全的。</p>
<p>之前文章提到，当初始化KafkaProducer时，会启动一个sender线程。当线程启动后会执行run()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.sender = newSender(logContext, kafkaClient, <span class="built_in">this</span>.metadata);</span><br><span class="line"><span class="built_in">this</span>.ioThread = <span class="keyword">new</span> <span class="title class_">KafkaThread</span>(ioThreadName, <span class="built_in">this</span>.sender, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">this</span>.ioThread.start();</span><br></pre></td></tr></table></figure>

<h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// main loop, runs until close is called</span></span><br><span class="line">       <span class="keyword">while</span> (running) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               runOnce();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;Uncaught error in kafka producer I/O thread: &quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!forceClose &amp;&amp; ((<span class="built_in">this</span>.accumulator.hasUndrained() || <span class="built_in">this</span>.client.inFlightRequestCount() &gt; <span class="number">0</span>) || hasPendingTransactionalRequests())) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               runOnce();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;Uncaught error in kafka producer I/O thread: &quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!forceClose &amp;&amp; transactionManager != <span class="literal">null</span> &amp;&amp; transactionManager.hasOngoingTransaction()) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               runOnce();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;Uncaught error in kafka producer I/O thread: &quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的网络请求都封装到runOnce()方法中，首先让我们来看run()方法中的三次调用吧</p>
<ol>
<li>主循环，直到running状态为false才会退出。running 在Sender类的构造方法中完成了赋值，赋值为true。</li>
<li>当running状态为false才会走到这里，虽然停止接受请求了，但是事务处理器，数据缓存器活或等待确认的还有请求，所以需要等待这些完成。</li>
<li>如果一些提交或者中止没有通过事务管理器管理，那么进行中止。</li>
</ol>
<h3 id="RunOnce"><a href="#RunOnce" class="headerlink" title="RunOnce"></a>RunOnce</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">runOnce</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为事务操作，对主流程影响不大，故这里不过多解释</span></span><br><span class="line">        <span class="keyword">if</span> (transactionManager != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果事务管理器有错误，那么停止运行，不再继续发送</span></span><br><span class="line">                <span class="keyword">if</span> (transactionManager.hasFatalError()) &#123;</span><br><span class="line">                    client.poll(retryBackoffMs, time.milliseconds());</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check whether we need a new producerId. If so, we will enqueue an InitProducerId</span></span><br><span class="line">                <span class="comment">// request which will be sent below</span></span><br><span class="line">                transactionManager.bumpIdempotentEpochAndResetIdIfNeeded();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (maybeSendAndPollTransactionalRequest()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">                <span class="comment">// This is already logged as error, but propagated here to perform any clean ups.</span></span><br><span class="line">                log.trace(<span class="string">&quot;Authentication exception while processing transactional request&quot;</span>, e);</span><br><span class="line">                transactionManager.authenticationFailed(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeMs</span> <span class="operator">=</span> time.milliseconds();</span><br><span class="line">        <span class="comment">// sender线程具体执行的地方</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">pollTimeout</span> <span class="operator">=</span> sendProducerData(currentTimeMs);</span><br><span class="line">        <span class="comment">// 实际的socket io操作</span></span><br><span class="line">        client.poll(pollTimeout, currentTimeMs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际发送数据的方法都封装在sendProducerData中，网络IO操作封装在poll()方法中，接下来让我们一一解析。</p>
<h3 id="SendProducerData"><a href="#SendProducerData" class="headerlink" title="SendProducerData"></a>SendProducerData</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">sendProducerData</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 拉取集群元数据信息</span></span><br><span class="line">        <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> metadata.fetch();</span><br><span class="line">        <span class="comment">// 2. 获取可以发送recordBatch的分区列表</span></span><br><span class="line">        RecordAccumulator.<span class="type">ReadyCheckResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.accumulator.ready(cluster, now);</span><br><span class="line">        <span class="comment">// 3. 获取所有可以发送的ProducerBatch（key是node.id,value是发送到该node的request列表）</span></span><br><span class="line">        Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; batches = <span class="built_in">this</span>.accumulator.drain(cluster, result.readyNodes, <span class="built_in">this</span>.maxRequestSize, now);</span><br><span class="line">        <span class="comment">// 增加到 inFlightBatches 发送中队列</span></span><br><span class="line">        addToInflightBatches(batches);</span><br><span class="line">        <span class="comment">// 保证一个partition只有一个recordBatch在发送，保证了有序性。max.in.flight.requests.per.connection设置为1时会保证</span></span><br><span class="line">        <span class="keyword">if</span> (guaranteeMessageOrder) &#123;</span><br><span class="line">            <span class="comment">// Mute all the partitions drained</span></span><br><span class="line">            <span class="keyword">for</span> (List&lt;ProducerBatch&gt; batchList : batches.values()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (ProducerBatch batch : batchList)</span><br><span class="line">                    <span class="built_in">this</span>.accumulator.mutePartition(batch.topicPartition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 过期数据处理</span></span><br><span class="line">        accumulator.resetNextBatchExpiryTime();</span><br><span class="line">        <span class="comment">// 获取发送超时的列表</span></span><br><span class="line">        List&lt;ProducerBatch&gt; expiredInflightBatches = getExpiredInflightBatches(now);</span><br><span class="line">        <span class="comment">// 获取在 accumulator 时间太久了，已经要过期了的batches</span></span><br><span class="line">        List&lt;ProducerBatch&gt; expiredBatches = <span class="built_in">this</span>.accumulator.expiredBatches(now);</span><br><span class="line">        <span class="comment">// 将发送时间超时的列表加入到过期列表中</span></span><br><span class="line">        expiredBatches.addAll(expiredInflightBatches);</span><br><span class="line">        <span class="comment">// 5. 发送 Producer 请求，这个方法会调用 NetworkClient.send() 来发送 clientRequest。</span></span><br><span class="line">        sendProduceRequests(batches, now);</span><br><span class="line">        <span class="keyword">return</span> pollTimeout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以看出 sendProducerData 主要分为5个步骤</p>
<ol>
<li>从缓存中获取集群元数据信息，后续所有操作都依赖元数据信息。</li>
<li>根据元数据信息的集群信息，获取accumulator中所有已经ready的batches。</li>
<li>根据broker进行数据分组，因为同一个broker可能有很多个partition，为了减少网络请求的开销，将同一个Node节点的数据聚合在一起。</li>
<li>超时&amp;过期数据处理</li>
<li>调用NetworkClient完成网络操作，NetworkClient底层依赖于Select来完成。注意这个方法只是为网络发送作准备，将数据放到一个等待队列中，而真正的网络IO操作发生在Client.poll()中</li>
</ol>
<h3 id="SendProduceRequests"><a href="#SendProduceRequests" class="headerlink" title="SendProduceRequests"></a>SendProduceRequests</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendProduceRequest</span><span class="params">(<span class="type">long</span> now, <span class="type">int</span> destination, <span class="type">short</span> acks, <span class="type">int</span> timeout, List&lt;ProducerBatch&gt; batches)</span> &#123;</span><br><span class="line">    <span class="comment">// 将批处理数据按照分区保存在一个Map中，以便后面处理响应时使用</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, ProducerBatch&gt; recordsByPartition = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(batches.size());</span><br><span class="line">    <span class="comment">// 创建ProduceRequestData.TopicProduceDataCollection以包含批处理的记录</span></span><br><span class="line">    ProduceRequestData.<span class="type">TopicProduceDataCollection</span> <span class="variable">tpd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProduceRequestData</span>.TopicProduceDataCollection();</span><br><span class="line">    <span class="comment">// 遍历每个ProducerBatch对象</span></span><br><span class="line">    <span class="keyword">for</span> (ProducerBatch batch : batches) &#123;</span><br><span class="line">        <span class="type">TopicPartition</span> <span class="variable">tp</span> <span class="operator">=</span> batch.topicPartition;</span><br><span class="line">        <span class="comment">// 获取TopicPartition和MemoryRecords对象</span></span><br><span class="line">        <span class="type">MemoryRecords</span> <span class="variable">records</span> <span class="operator">=</span> batch.records();</span><br><span class="line"></span><br><span class="line">        ProduceRequestData.<span class="type">TopicProduceData</span> <span class="variable">tpData</span> <span class="operator">=</span> tpd.find(tp.topic());</span><br><span class="line">        <span class="keyword">if</span> (tpData == <span class="literal">null</span>) &#123;</span><br><span class="line">            tpData = <span class="keyword">new</span> <span class="title class_">ProduceRequestData</span>.TopicProduceData().setName(tp.topic());</span><br><span class="line">            tpd.add(tpData);</span><br><span class="line">        &#125;</span><br><span class="line">        tpData.partitionData().add(<span class="keyword">new</span> <span class="title class_">ProduceRequestData</span>.PartitionProduceData()</span><br><span class="line">                .setIndex(tp.partition())</span><br><span class="line">                .setRecords(records));</span><br><span class="line">        <span class="comment">// 将TopicPartition和ProducerBatch添加到recordsByPartition Map中</span></span><br><span class="line">        recordsByPartition.put(tp, batch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造ProduceRequest对象</span></span><br><span class="line">    ProduceRequest.<span class="type">Builder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span> ProduceRequest.forMagic(minUsedMagic,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProduceRequestData</span>()</span><br><span class="line">                    .setAcks(acks)</span><br><span class="line">                    .setTimeoutMs(timeout)</span><br><span class="line">                    .setTransactionalId(transactionalId)</span><br><span class="line">                    .setTopicData(tpd));</span><br><span class="line">    <span class="comment">// 创建一个回调函数，用于处理响应</span></span><br><span class="line">    <span class="type">RequestCompletionHandler</span> <span class="variable">callback</span> <span class="operator">=</span> response -&gt; handleProduceResponse(response, recordsByPartition, time.milliseconds());</span><br><span class="line">    <span class="comment">// 将ProduceRequest对象封装成ClientRequest并发送到指定的节点</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">nodeId</span> <span class="operator">=</span> Integer.toString(destination);</span><br><span class="line">    <span class="type">ClientRequest</span> <span class="variable">clientRequest</span> <span class="operator">=</span> client.newClientRequest(nodeId, requestBuilder, now, acks != <span class="number">0</span>,</span><br><span class="line">            requestTimeoutMs, callback);</span><br><span class="line">    client.send(clientRequest, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendProduceRequest方法主要是构造ProduceRequest、ClientResponse对象，并调用client.send()方法将待发送数据暂存到队列中，等待网络IO将数据发送出去。同时也构建回调对象，用于处理响应的数据。详细介绍参见「Kafka源码美学」之网络发送</p>
<p>下面分析client.poll()方法</p>
<h3 id="client-poll"><a href="#client-poll" class="headerlink" title="client.poll()"></a>client.poll()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">        ensureActive();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!abortedSends.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// If there are aborted sends because of unsupported version exceptions or disconnects,</span></span><br><span class="line">            <span class="comment">// handle them immediately without waiting for Selector#poll.</span></span><br><span class="line">            List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            handleAbortedSends(responses);</span><br><span class="line">            completeResponses(responses);</span><br><span class="line">            <span class="keyword">return</span> responses;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否需要更新元数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">metadataTimeout</span> <span class="operator">=</span> metadataUpdater.maybeUpdate(now);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用Selector.poll()进行socket IO操作</span></span><br><span class="line">            <span class="built_in">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, defaultRequestTimeoutMs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Unexpected error during I/O&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process completed actions</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">updatedNow</span> <span class="operator">=</span> <span class="built_in">this</span>.time.milliseconds();</span><br><span class="line">        List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 处理已经完成的请求发送</span></span><br><span class="line">        handleCompletedSends(responses, updatedNow);</span><br><span class="line">        <span class="comment">// 处理从server端收到的response</span></span><br><span class="line">        handleCompletedReceives(responses, updatedNow);</span><br><span class="line">        <span class="comment">// 处理连接失败的请求</span></span><br><span class="line">        handleDisconnections(responses, updatedNow);</span><br><span class="line">        <span class="comment">// 处理新建立的连接(还不能发送请求)</span></span><br><span class="line">        handleConnections();</span><br><span class="line">        <span class="comment">// 对新建立的连接，发送apiVersionRequests请求</span></span><br><span class="line">        handleInitiateApiVersionRequests(updatedNow);</span><br><span class="line">        <span class="comment">// 处理timeout的连接，关闭连接</span></span><br><span class="line">        handleTimedOutConnections(responses, updatedNow);</span><br><span class="line">        handleTimedOutRequests(responses, updatedNow);</span><br><span class="line">        completeResponses(responses);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> responses;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Send线程中主要做了如下几件事：</p>
<ul>
<li>获取accumulator中已经ready的producerBatch，并转化为以node节点为分组ClientRequest</li>
<li>调用NetWorkClient的send方法，做好发送ClientRequest的准备</li>
<li>全部就绪后调用NetWorkClient的poll方法，触发网络IO，把消息真正发送出去</li>
</ul>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>曾就职于拼多多，前蚂蚁金服高级Java开发。平时会分享些工作中遇到的技术问题，包括但不限于Java、分布式、大数据。也会分享些理财笔记。关注公众号，了解更多~</p>
<p><img src="/blog/img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpeg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zgyyq.github.io/blog/2023/04/25/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="最光阴">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="最光阴写字的地方">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2023/04/25/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/" class="post-title-link" itemprop="url">post</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-25 22:00:49 / 修改时间：22:02:02" itemprop="dateCreated datePublished" datetime="2023-04-25T22:00:49+08:00">2023-04-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">最光阴</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">最光阴</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
